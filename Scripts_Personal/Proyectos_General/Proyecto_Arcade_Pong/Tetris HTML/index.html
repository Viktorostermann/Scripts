<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tetris Deluxe</title>
  <style>
    body {
      background: #222;
      color: #fff;
      font-family: monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 30px;
      overflow: hidden;
    }
    h1 { letter-spacing: 2px; }
    #container {
      display: flex;
      gap: 40px;
      align-items: flex-start;
      z-index: 1;
    }
    #tetris {
      border: 4px solid #fff;
      background: #111;
      image-rendering: pixelated;
      margin-top: 20px;
      display: block;
      z-index: 2;
    }
    #preview {
      border: 2px solid #888;
      margin-top: 20px;
      background: #333;
      display: block;
      z-index: 2;
    }
    #score, #highscores, #instructions, #gameover, #mode, #theme {
      text-align: center;
      width: 100%;
    }
    #score { font-size: 20px; margin: 12px; }
    #mode { font-size: 16px; margin: 12px;}
    #theme { font-size: 15px; margin: 12px;}
    #instructions { font-size: 14px; color: #bbb; margin-top: 16px;}
    #gameover {
      color: #ff4444;
      font-size: 2em;
      margin: 20px;
      display: none;
    }
    #pause {
      color: #ff0;
      font-size: 1.8em;
      position: absolute;
      left: 50%; top: 170px;
      transform: translateX(-50%);
      display: none;
      background: rgba(20,20,20,0.95);
      border: 2px solid #fff;
      padding: 30px 60px;
      z-index: 10;
    }
    #highscores { 
      background: #181818;
      border-radius: 6px;
      margin-top: 18px;
      padding: 8px 12px 16px 12px;
      font-size: 15px;
      min-width: 180px;
      border: 2px solid #888;
      color: #fff;
      display: inline-block;
      z-index: 2;
    }
    .menu-selected { color: #ff0; text-shadow: 0 0 12px #0ff, 0 0 24px #0ff; }
    .menu-normal { color: #fff; text-shadow: 0 0 6px #0ff; }
    #container { position: relative; }
    #menu-bg-canvas {
      position: fixed;
      left: 0; top: 0;
      z-index: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      filter: blur(1.5px) brightness(1.2) contrast(1.08);
    } 
    #menu-bg-img {
      position: fixed;
      left: 0; top: 0;
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      z-index: 0;
      opacity: 0.17;
      pointer-events: none;
      
      @keyframes shake {
  0% { transform: translate(1px, 1px); }
  20% { transform: translate(-2px, 0px); }
  40% { transform: translate(2px, 2px); }
  60% { transform: translate(-1px, -1px); }
  80% { transform: translate(1px, -2px); }
  100% { transform: translate(0px, 0px); }
}

.shake {
  animation: shake 0.25s ease-in-out;
}


    }
  </style>
</head>
<body>
  <!-- Neon Menu Background -->
  <canvas id="menu-bg-canvas"></canvas>
  <!-- Custom background image for the menu -->
  <img id="menu-bg-img" src="futuristic_city.webp" alt="Menu Background" />
  <h1>Tetris Deluxe</h1>
  <div id="container">
    <canvas id="tetris" width="200" height="400"></canvas>
    <div>
      <canvas id="preview" width="100" height="100"></canvas>
      <div id="mode"></div>
      <div id="theme"></div>
      <div id="score">Score: 0</div>
      <div id="highscores"></div>
    </div>
  </div>
  <div id="pause"></div>
  <div id="gameover">Game Over!<br>Press <b>R</b> to restart</div>
  <div id="instructions">
    Arrows: Move/Rotate &nbsp;|&nbsp; Down: Soft Drop &nbsp;|&nbsp; Up: Rotate &nbsp;|&nbsp; Space: Hard Drop <br>
    <b>P</b>: Pause &nbsp;|&nbsp; <b>M</b>: Menu &nbsp;|&nbsp; <b>T</b>: Theme &nbsp;|&nbsp; <b>C</b>: Mode
  </div>
  <audio id="sfx-line-explosion" src="line_explosion.wav"></audio>
  <audio id="bgmusic" src="tetris.mp3" loop></audio>
  <audio id="menusong" src="menu_song.mp3" loop></audio>
  <script>
const COLS = 10, ROWS = 20, BLOCK = 20;
const canvas = document.getElementById('tetris');
const ctx = canvas.getContext('2d');
const preview = document.getElementById('preview');
const pctx = preview.getContext('2d');
const scoreElem = document.getElementById('score');
const highElem = document.getElementById('highscores');
const gameoverElem = document.getElementById('gameover');
const pauseElem = document.getElementById('pause');
const modeElem = document.getElementById('mode');
const themeElem = document.getElementById('theme');

const sfxLineExplosion = document.getElementById('sfx-line-explosion');
const bgmusic = document.getElementById('bgmusic');
const menusong = document.getElementById('menusong');

// --- THEMES ---
const THEMES = [
  {
    name: "Classic",
    colors: ['#000', '#0ff','#00f','#f80','#ff0','#0f0','#f00','#a0f'],
    bg: "#111",
    border: "#fff"
  },
  {
    name: "Ocean",
    colors: ['#041f2a','#19aedb','#3b7dc7','#19dbd4','#fff99d','#71ebff','#4989b3','#e7e1ff'],
    bg: "#0b2737", border: "#19aedb"
  },
  {
    name: "Candy",
    colors: ['#fff','#f690c7','#f5d300','#f97924','#95e06c','#ff706c','#a7e5fb','#fbe8c6'],
    bg: "#fee5e5", border: "#f97924"
  },
  {
    name: "Matrix",
    colors: ['#070','#0f0','#0c0','#090','#8f0','#0cc','#f0f','#fff'],
    bg: "#000", border: "#0f0"
  },
];
let themeIndex = 0;

// --- MODES ---
const MODES = [
  { name: "Normal", drop: 500, description: "" },
  { name: "Ultra Fast", drop: 120, description: "Fall speed is super high!" },
  { name: "10 Lines Rush", drop: 500, description: "Clear 10 lines as fast as possible." }
];
let modeIndex = 0;

// --- HIGH SCORES ---
const HIGHSCORE_KEY = "tetrisdeluxe_highscores";
function getHighScores() {
  return JSON.parse(localStorage.getItem(HIGHSCORE_KEY) || "[]");
}
function setHighScore(score, mode) {
  let scores = getHighScores();
  scores.push({score, mode, date: new Date().toLocaleDateString()});
  scores = scores.sort((a,b) => b.score-a.score).slice(0,5);
  localStorage.setItem(HIGHSCORE_KEY, JSON.stringify(scores));
}
function showHighScores() {
  const scores = getHighScores();
  highElem.innerHTML = "<b>High Scores:</b><br>" + 
    (scores.length ? scores.map(s=>`${s.score} (${s.mode})`).join("<br>") : "None yet!");
}

// --- PIECES ---
const SHAPES = [
  [], // empty
  [[1,1,1,1]], // I
  [[2,0,0],[2,2,2]], // J
  [[0,0,3],[3,3,3]], // L
  [[4,4],[4,4]], // O
  [[0,5,5],[5,5,0]], // S
  [[6,6,0],[0,6,6]], // Z
  [[0,7,0],[7,7,7]], // T
];
function randomPiece() {
  const id = 1 + Math.floor(Math.random() * 7);
  return {
    id,
    shape: SHAPES[id].map(row => row.slice()),
    x: Math.floor(COLS/2) - Math.ceil(SHAPES[id][0].length/2),
    y: -SHAPES[id].length + 1
  };
}

// --- GAME STATE ---
let board, piece, next, dropStart, dropInterval, score, gameOver, linesCleared, linesTarget, timerStart, timerNow;
let gameState = "menu"; // "menu", "playing", "paused", "gameover"
let menuIndex = 0;
const menuOptions = ["Start Game", "Show Controls", "Theme", "Mode", "High Scores", "Quit"];

// --- EXPLOSION EFFECT ---
let explosions = [];
function triggerExplosion(y) {
  for(let x=0; x<COLS; ++x) {
    let ex = {x, y, particles: []};
    for(let i=0; i<8; ++i) {
      let angle = Math.random()*2*Math.PI;
      let speed = 2+Math.random()*2;
      ex.particles.push({
        x: x*BLOCK + BLOCK/2,
        y: y*BLOCK + BLOCK/2,
        dx: Math.cos(angle)*speed,
        dy: Math.sin(angle)*speed,
        life: 20 + Math.random()*10
      });
    }
    explosions.push(ex);
  }
}
function updateExplosions() {
  for (let ex of explosions) {
    for (let p of ex.particles) {
      p.x += p.dx;
      p.y += p.dy;
      p.dy += 0.2;
      p.life--;
    }
    ex.particles = ex.particles.filter(p => p.life > 0);
  }
  explosions = explosions.filter(ex => ex.particles.length > 0);
}
function drawExplosions() {
  for (let ex of explosions) {
    for (let p of ex.particles) {
      ctx.fillStyle = "#fff";
      ctx.globalAlpha = Math.max(0, p.life/30);
      ctx.beginPath();
      ctx.arc(p.x, p.y, 3, 0, 2*Math.PI);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }
}

// --- MENU NEON BACKGROUND ---
const menubgcanvas = document.getElementById('menu-bg-canvas');
const menubgctx = menubgcanvas.getContext('2d');
let neonShapes = [];
function resizeMenuBgCanvas() {
  menubgcanvas.width = window.innerWidth;
  menubgcanvas.height = window.innerHeight;
}
resizeMenuBgCanvas();
window.addEventListener('resize', resizeMenuBgCanvas);

// Generate random neon shapes
function generateNeonShapes() {
  neonShapes = [];
  // Neon lines
  for (let i = 0; i < 12; i++) {
    neonShapes.push({
      type: 'line',
      x: Math.random() * window.innerWidth,
      y: Math.random() * window.innerHeight,
      len: 100 + Math.random() * 350,
      angle: Math.random() * Math.PI * 2,
      color: `hsl(${170 + Math.random()*100},100%,60%)`,
      speed: 0.12 + Math.random()*0.13
    });
  }
  // Neon circles
  for (let i = 0; i < 8; i++) {
    neonShapes.push({
      type: 'circle',
      x: Math.random() * window.innerWidth,
      y: Math.random() * window.innerHeight,
      r: 18 + Math.random() * 50,
      color: `hsl(${250 + Math.random()*100},95%,60%)`,
      dx: -2 + Math.random()*4,
      dy: -2 + Math.random()*4,
      dr: 0.05 + Math.random()*0.06
    });
  }
}
generateNeonShapes();

function updateNeonShapes() {
  for (const s of neonShapes) {
    if (s.type === 'line') {
      s.x += Math.cos(s.angle) * s.speed;
      s.y += Math.sin(s.angle) * s.speed;
      s.angle += (-0.01 + Math.random()*0.02);
      if (s.x < -s.len || s.x > window.innerWidth + s.len || s.y < -s.len || s.y > window.innerHeight + s.len) {
        s.x = Math.random() * window.innerWidth;
        s.y = Math.random() * window.innerHeight;
      }
    }
    if (s.type === 'circle') {
      s.x += s.dx;
      s.y += s.dy;
      s.r += Math.sin(s.r * s.dr) * 0.6;
      if (s.x < -s.r || s.x > window.innerWidth + s.r) s.dx *= -1;
      if (s.y < -s.r || s.y > window.innerHeight + s.r) s.dy *= -1;
      if (s.r < 10) s.r = 15;
      if (s.r > 80) s.r = 30;
    }
  }
}

function drawNeonMenuBg() {
  menubgctx.clearRect(0,0,menubgcanvas.width,menubgcanvas.height);

  // Draw neon shapes
  for (const s of neonShapes) {
    if (s.type === 'line') {
      menubgctx.save();
      menubgctx.translate(s.x, s.y);
      menubgctx.rotate(s.angle);
      menubgctx.shadowColor = s.color;
      menubgctx.shadowBlur = 24;
      menubgctx.strokeStyle = s.color;
      menubgctx.globalAlpha = 0.55;
      menubgctx.lineWidth = 4.5 + Math.sin(s.angle*2)*2.5;
      menubgctx.beginPath();
      menubgctx.moveTo(-s.len/2, 0);
      menubgctx.lineTo(s.len/2, 0);
      menubgctx.stroke();
      menubgctx.globalAlpha = 1;
      menubgctx.restore();
    }
    if (s.type === 'circle') {
      menubgctx.save();
      menubgctx.globalAlpha = 0.22 + (Math.sin(s.r*0.2)+1)*0.12;
      menubgctx.shadowColor = s.color;
      menubgctx.shadowBlur = 32;
      menubgctx.strokeStyle = s.color;
      menubgctx.lineWidth = 5.5;
      menubgctx.beginPath();
      menubgctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
      menubgctx.stroke();
      menubgctx.globalAlpha = 1;
      menubgctx.restore();
    }
  }
}

function animateNeonMenuBg() {
  if (gameState === "menu") {
    updateNeonShapes();
    drawNeonMenuBg();
    requestAnimationFrame(animateNeonMenuBg);
  } else {
    menubgctx.clearRect(0,0,menubgcanvas.width,menubgcanvas.height); // Clear when out of menu
  }
}

// --- GAME LOGIC ---
function reset() {
  board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
  score = 0;
  linesCleared = 0;
  linesTarget = (MODES[modeIndex].name === "10 Lines Rush") ? 10 : null;
  piece = randomPiece();
  next = randomPiece();
  dropInterval = MODES[modeIndex].drop;
  gameOver = false;
  scoreElem.textContent = "Score: 0";
  gameoverElem.style.display = "none";
  pauseElem.style.display = "none";
  modeElem.innerHTML = `<b>Mode:</b> ${MODES[modeIndex].name}` + (MODES[modeIndex].description?`<br>${MODES[modeIndex].description}`:"");
  themeElem.innerHTML = `<b>Theme:</b> ${THEMES[themeIndex].name}`;
  showHighScores();
  timerStart = Date.now();
  timerNow = 0;
  explosions = [];
}

function draw() {
  ctx.fillStyle = THEMES[themeIndex].bg;
  ctx.fillRect(0,0,COLS*BLOCK,ROWS*BLOCK);
  for(let y=0; y<ROWS; ++y) for(let x=0; x<COLS; ++x)
    drawBlock(x, y, board[y][x]);
  if (gameState === "playing" || gameState === "paused") {
    drawPiece(piece, piece.x, piece.y);
  }
  drawExplosions();
  ctx.strokeStyle = THEMES[themeIndex].border;
  ctx.lineWidth = 4;
  ctx.strokeRect(0,0,COLS*BLOCK,ROWS*BLOCK);
  drawPreview();
}

function drawPiece(p, px, py) {
  for(let y=0; y<p.shape.length; ++y)
    for(let x=0; x<p.shape[y].length; ++x)
      if(p.shape[y][x]) drawBlock(px + x, py + y, p.shape[y][x]);
}

function drawBlock(x, y, id) {
  if (id) {
    ctx.fillStyle = THEMES[themeIndex].colors[id];
    ctx.fillRect(x*BLOCK, y*BLOCK, BLOCK, BLOCK);
    ctx.strokeStyle = "#222";
    ctx.strokeRect(x*BLOCK, y*BLOCK, BLOCK, BLOCK);
  }
}

function drawPreview() {
  pctx.fillStyle = "#222";
  pctx.fillRect(0,0,preview.width,preview.height);
  const shape = next.shape;
  let offsetX = Math.floor((5-shape[0].length)/2);
  let offsetY = Math.floor((5-shape.length)/2);
  for(let y=0; y<shape.length; ++y)
    for(let x=0; x<shape[y].length; ++x)
      if(shape[y][x])
        drawPreviewBlock(x+offsetX, y+offsetY, shape[y][x]);
  pctx.strokeStyle = "#888";
  pctx.strokeRect(0,0,preview.width,preview.height);
}
function drawPreviewBlock(x, y, id) {
  if(id) {
    pctx.fillStyle = THEMES[themeIndex].colors[id];
    pctx.fillRect(x*20, y*20, 20, 20);
    pctx.strokeStyle = "#222";
    pctx.strokeRect(x*20, y*20, 20, 20);
  }
}

function collide(p, px, py) {
  for(let y=0; y<p.shape.length; ++y)
    for(let x=0; x<p.shape[y].length; ++x)
      if(p.shape[y][x]) {
        let nx = px + x, ny = py + y;
        if(nx < 0 || nx >= COLS || ny >= ROWS) return true;
        if(ny >= 0 && board[ny][nx]) return true;
      }
  return false;
}

function lock() {
  for(let y=0; y<piece.shape.length; ++y)
    for(let x=0; x<piece.shape[y].length; ++x)
      if(piece.shape[y][x] && piece.y + y >= 0)
        board[piece.y + y][piece.x + x] = piece.shape[y][x];
}

function rotate(shape) {
  const rows = shape.length, cols = shape[0].length;
  let result = [];
  for(let x = 0; x < cols; ++x) {
    result[x] = [];
    for(let y = rows - 1; y >= 0; --y) {
      result[x][rows - 1 - y] = shape[y][x];
    }
  }
  return result;
}

function clearLines() {
  let lines = 0;
  for(let y=ROWS-1; y>=0; --y){
    if(board[y].every(val => val)){
      triggerExplosion(y);
      sfxLineExplosion.currentTime = 0;
      sfxLineExplosion.play();
      canvas.classList.add('shake');
      setTimeout(() => canvas.classList.remove('shake'), 250);
      board.splice(y,1);
      board.unshift(Array(COLS).fill(0));
      ++lines; ++y;
    }
  }
  if(lines){
    linesCleared += lines;
    score += [0,40,100,300,1200][lines];
    scoreElem.textContent = "Score: " + score;
    if (MODES[modeIndex].name === "Ultra Fast") {
      dropInterval = Math.max(50, dropInterval - 10*lines);
    }
  }
}

function drop() {
  if(!gameOver && gameState === "playing"){
    if(!collide(piece, piece.x, piece.y+1)){
      piece.y++;
    }else{
      lock();
      clearLines();
      piece = next;
      next = randomPiece();
      if(collide(piece, piece.x, piece.y)){
        gameOver = true;
        gameState = "gameover";
        gameoverElem.style.display = "";
        setHighScore(score, MODES[modeIndex].name);
        showHighScores();
        bgmusic.pause();
      }
      if (linesTarget && linesCleared >= linesTarget) {
        gameOver = true;
        gameState = "gameover";
        gameoverElem.innerHTML = `You Win!<br>Time: ${(timerNow/1000).toFixed(2)}s<br>Press <b>R</b> to restart`;
        gameoverElem.style.display = "";
        setHighScore(score, MODES[modeIndex].name+" (10 Lines)");
        showHighScores();
        bgmusic.pause();
      }
    }
    draw();
  }
}

function hardDrop() {
  let moved = false;
  while(!collide(piece, piece.x, piece.y+1)) {
    piece.y++;
    moved = true;
  }
  drop();
}

function move(dx) {
  if(!collide(piece, piece.x+dx, piece.y)){
    piece.x += dx;
    draw();
  }
}

function rotatePiece() {
  const rotated = rotate(piece.shape);
  if(!collide({shape: rotated}, piece.x, piece.y)){
    piece.shape = rotated;
    draw();
  }
}

// Menu logic
function drawMenu() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = THEMES[themeIndex].bg;
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.font = "24px monospace";
  ctx.fillStyle = "#fff";
  ctx.textAlign = "center";
  ctx.shadowColor = "#0ff";
  ctx.shadowBlur = 18;
  ctx.fillText("TETRIS DELUXE", canvas.width/2, 80);
  ctx.shadowBlur = 0;
  ctx.font = "18px monospace";
  menuOptions.forEach((opt, i) => {
    ctx.save();
    ctx.textAlign = "center";
    ctx.shadowColor = "#0ff";
    ctx.shadowBlur = 10;
    ctx.fillStyle = i === menuIndex ? "#ff0" : "#fff";
    ctx.globalAlpha = 1;
    ctx.fillText(opt, canvas.width/2, 160 + i*40);
    ctx.restore();
  });
}

// Neon menu background animate on state change
function handleMenuBg() {
  if (gameState === "menu") {
    document.getElementById('menu-bg-img').style.display = "";
    menubgcanvas.style.display = "";
    generateNeonShapes();
    animateNeonMenuBg();
    menusong.currentTime = 0;
    menusong.volume = 0.66;
    menusong.play();
    bgmusic.pause();
  } else {
    document.getElementById('menu-bg-img').style.display = "none";
    menubgcanvas.style.display = "none";
    menusong.pause();
  }
}

function drawPauseMenu() {
  pauseElem.innerHTML = `<b>PAUSED</b><br><br>
    <span class="menu-${pauseMenuIndex===0?'selected':'normal'}">Resume</span><br>
    <span class="menu-${pauseMenuIndex===1?'selected':'normal'}">Restart</span><br>
    <span class="menu-${pauseMenuIndex===2?'selected':'normal'}">Main Menu</span>`;
  pauseElem.style.display = "";
}
let pauseMenuIndex = 0;

function update(now) {
  if(gameState === "playing") {
    timerNow = Date.now() - timerStart;
    if(!dropStart) dropStart = now;
    if(now - dropStart > dropInterval){
      drop();
      dropStart = now;
    }
    updateExplosions();
    draw();
    requestAnimationFrame(update);
  }
}

// Controls
document.addEventListener('keydown', e => {
  // MENU CONTROLS
  if(gameState === "menu") {
    if(e.key === "ArrowUp") {
      menuIndex = (menuIndex-1+menuOptions.length)%menuOptions.length;
      drawMenu();
    } else if(e.key === "ArrowDown") {
      menuIndex = (menuIndex+1)%menuOptions.length;
      drawMenu();
    } else if(e.key === "Enter" || e.key === " ") {
      if(menuOptions[menuIndex] === "Start Game") {
        gameState = "playing";
        reset();
        draw();
        dropStart = 0;
        menusong.pause();
        bgmusic.currentTime=0; 
        bgmusic.volume = 0.8;
        bgmusic.play();
        handleMenuBg();
        requestAnimationFrame(update);
      } else if(menuOptions[menuIndex] === "Show Controls") {
        alert("Arrows = Move/Rotate\nSpace = Hard Drop\nR = Restart\nP = Pause\nM = Menu\nT = Theme\nC = Mode");
        drawMenu();
      } else if(menuOptions[menuIndex] === "Theme") {
        themeIndex = (themeIndex+1)%THEMES.length;
        drawMenu();
      } else if(menuOptions[menuIndex] === "Mode") {
        modeIndex = (modeIndex+1)%MODES.length;
        drawMenu();
      } else if(menuOptions[menuIndex] === "High Scores") {
        alert(getHighScores().map(s=>`${s.score} (${s.mode})`).join("\n") || "None yet!");
        drawMenu();
      } else if(menuOptions[menuIndex] === "Quit") {
        alert("Thank you for playing!");
        drawMenu();
      }
    }
    return;
  }
  // PAUSE MENU CONTROLS
  if(gameState === "paused") {
    if(e.key === "ArrowUp") {
      pauseMenuIndex = (pauseMenuIndex-1+3)%3;
      drawPauseMenu();
    } else if(e.key === "ArrowDown") {
      pauseMenuIndex = (pauseMenuIndex+1)%3;
      drawPauseMenu();
    } else if(e.key === "Enter" || e.key === " ") {
      if(pauseMenuIndex===0) { // Resume
        gameState = "playing";
        pauseElem.style.display = "none";
        bgmusic.play();
        requestAnimationFrame(update);
      } else if(pauseMenuIndex===1) { // Restart
        gameState = "playing";
        reset();
        draw();
        dropStart = 0;
        bgmusic.currentTime=0; 
        bgmusic.play();
        requestAnimationFrame(update);
      } else if(pauseMenuIndex===2) { // Main Menu
        gameState = "menu";
        bgmusic.pause();
        handleMenuBg();
        drawMenu();
        pauseElem.style.display = "none";
      }
    }
    return;
  }
  // GAME/PLAYING CONTROLS
  if(gameState === "playing" && !gameOver) {
    if(e.key === "ArrowLeft") move(-1);
    else if(e.key === "ArrowRight") move(1);
    else if(e.key === "ArrowDown") drop();
    else if(e.key === "ArrowUp") rotatePiece();
    else if(e.key === " ") hardDrop();
    else if(e.key.toLowerCase() === "p") {
      gameState = "paused";
      bgmusic.pause();
      pauseMenuIndex = 0;
      drawPauseMenu();
    } else if(e.key.toLowerCase() === "m") {
      gameState = "menu";
      bgmusic.pause();
      handleMenuBg();
      drawMenu();
    } else if(e.key.toLowerCase() === "t") {
      themeIndex = (themeIndex+1)%THEMES.length;
      themeElem.innerHTML = `<b>Theme:</b> ${THEMES[themeIndex].name}`;
      draw();
      drawPreview();
    } else if(e.key.toLowerCase() === "c") {
      modeIndex = (modeIndex+1)%MODES.length;
      modeElem.innerHTML = `<b>Mode:</b> ${MODES[modeIndex].name}` + (MODES[modeIndex].description?`<br>${MODES[modeIndex].description}`:"");
      reset();
      draw();
    }
    return;
  }
// Gaem over 
  if(gameState === "gameover") {
    if(e.key.toLowerCase() === 'r') {
      gameState = "playing";
      reset();
      draw();
      dropStart = 0;
      bgmusic.currentTime=0; 
      bgmusic.play();
      requestAnimationFrame(update);
    } else if(e.key.toLowerCase() === 'm') {
      gameState = "menu";
      bgmusic.pause();
      handleMenuBg();
      drawMenu();
    }
    return;
  }
});

// On page load
showHighScores();
drawMenu();
handleMenuBg();
animateNeonMenuBg();

// ⚠️ Defer audio play until user interacts
menusong.readyToPlay = false;

function enableAudioAfterClick() {
  menusong.volume = 0.66;
  menusong.play().then(() => {
    menusong.readyToPlay = true;
    console.log("Menu music autoplay unlocked.");
  }).catch(e => console.warn("Autoplay blocked:", e));
  document.removeEventListener('click', enableAudioAfterClick);
}
document.addEventListener('click', enableAudioAfterClick);

  </script>
</body>
</html>